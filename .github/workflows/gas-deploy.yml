name: GAS staged test & deploy (single workflow)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

concurrency:
  group: gas-ci-${{ github.ref }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash

jobs:
  test-stage:
    runs-on: ubuntu-latest
    timeout-minutes: 25

    steps:
      - name: "Checkout"
        uses: actions/checkout@v4

      - name: "Setup Node 18"
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: "Install deps"
        run: |
          if [ -f package-lock.json ]; then npm ci; else npm install; fi

      - name: "Install latest clasp"
        run: npm i -g @google/clasp

      # --- write clasprc (raw JSON 或 base64 皆可) ---
      - name: "Write ~/.clasprc.json"
        env:
          CLASPRC_JSON: ${{ secrets.CLASPRC_JSON }}
        run: |
          set -euo pipefail
          [ -n "${CLASPRC_JSON:-}" ] || { echo "::error::Missing CLASPRC_JSON"; exit 1; }
          node -e "
            const fs=require('fs');const p=process.env.HOME+'/.clasprc.json';
            let s=process.env.CLASPRC_JSON||'';let j;
            try{ j=JSON.parse(s); }catch(e){ s=s.replace(/\s+/g,''); j=JSON.parse(Buffer.from(s,'base64').toString()); }
            if(!j.token && j.tokens && j.tokens.default){ j.token=j.tokens.default; }
            fs.writeFileSync(p, JSON.stringify(j,null,2));
          "
          test -s "$HOME/.clasprc.json"
          cp "$HOME/.clasprc.json" "$GITHUB_WORKSPACE/.clasprc.json"

      - name: "Ensure .clasp.json has scriptId"
        run: node -e "const j=require('./.clasp.json'); if(!j.scriptId){process.stderr.write('Missing scriptId\n');process.exit(2)}; console.log('scriptId=', j.scriptId)"

      - name: "Guard: appsscript.json must declare webapp"
        run: |
          node - <<'EOF'
          const fs = require('fs');
          const m = JSON.parse(fs.readFileSync('appsscript.json','utf8'));
          if (!m.webapp || !m.webapp.access || !m.webapp.executeAs) {
            console.error('appsscript.json missing webapp.access/executeAs');
            process.exit(1);
          }
          const okLog = ['STACKDRIVER','CLOUD','NONE'].includes(m.exceptionLogging||'STACKDRIVER');
          if (!okLog) {
            console.error('exceptionLogging must be STACKDRIVER|CLOUD|NONE, got:', m.exceptionLogging);
            process.exit(1);
          }
          console.log('webapp OK:', m.webapp, 'exceptionLogging=', m.exceptionLogging);
          EOF

      # BEFORE snapshot（文字解析 fallback）
      - name: "Snapshot BEFORE"
        run: |
          set -e
          clasp list-deployments > before.txt || clasp deployments > before.txt || true
          node -e "const fs=require('fs');const t=fs.readFileSync('before.txt','utf8');const ids=[...t.matchAll(/AK[a-zA-Z0-9_-]{20,}/g)].map(m=>m[0]);fs.writeFileSync('before.json',JSON.stringify([...new Set(ids)]));console.log('BEFORE IDs:',ids.join(',')||'(none)')"

      - name: "Ensure TEST_DEPLOYMENT_ID exists BEFORE"
        env:
          TEST_DEPLOYMENT_ID: ${{ secrets.TEST_DEPLOYMENT_ID }}
        run: node -e "const fs=require('fs'),id=process.env.TEST_DEPLOYMENT_ID;const arr=JSON.parse(fs.readFileSync('before.json','utf8'));if(!id||!arr.includes(id)){console.error('TEST_DEPLOYMENT_ID not found. IDs=',arr);process.exit(1)};console.log('Found test deployment ID BEFORE.')"

      # --- push & deploy to TEST ---
      - name: "Push to Apps Script (TEST)"
        run: clasp push -f

      - name: "Deploy to TEST"
        env:
          TEST_DEPLOYMENT_ID: ${{ secrets.TEST_DEPLOYMENT_ID }}
        run: |
          [ -n "${TEST_DEPLOYMENT_ID:-}" ] || { echo "::error::Missing TEST_DEPLOYMENT_ID"; exit 1; }
          clasp deploy --deploymentId "$TEST_DEPLOYMENT_ID" -d "CI STAGE ${GITHUB_SHA}"

      # AFTER snapshot (TEST)
      - name: "Snapshot AFTER (TEST)"
        env:
          TEST_DEPLOYMENT_ID: ${{ secrets.TEST_DEPLOYMENT_ID }}
        run: |
          set -e
          clasp list-deployments > after.txt || clasp deployments > after.txt || true
          node -e "const fs=require('fs');const t=fs.readFileSync('after.txt','utf8');const ids=[...t.matchAll(/AK[a-zA-Z0-9_-]{20,}/g)].map(m=>m[0]);fs.writeFileSync('after.json',JSON.stringify([...new Set(ids)]));console.log('AFTER IDs:',ids.join(',')||'(none)')"
          node -e "const fs=require('fs'),b=JSON.parse(fs.readFileSync('before.json','utf8')),a=JSON.parse(fs.readFileSync('after.json','utf8'));const id=process.env.TEST_DEPLOYMENT_ID;console.log('before=',b.length,'after=',a.length,'hasTarget=',a.includes(id)); if(!a.includes(id)){process.exit(1)}"

      # --- Unit tests / E2E tests (可先無檔；--if-present 不會 fail) ---
      - name: "Run unit tests (Jest)"
        run: npm test --if-present

      - name: "Run E2E tests (Puppeteer) against TEST"
        env:
          TEST_DEPLOYMENT_ID: ${{ secrets.TEST_DEPLOYMENT_ID }}
        run: npm run e2e --if-present

      # --- Health check on TEST（容忍 302 登入轉向） ---
      - name: "Health check (TEST)"
        env:
          TEST_DEPLOYMENT_ID: ${{ secrets.TEST_DEPLOYMENT_ID }}
        run: |
          set -e
          URL="https://script.google.com/macros/s/${TEST_DEPLOYMENT_ID}/exec?route=health&v=${GITHUB_SHA::7}"
          code=$(curl -sS -o /dev/null -w "%{http_code}" -D headers.txt "$URL" || true)
          loc=$(awk 'BEGIN{IGNORECASE=1}/^Location:/{print $2}' headers.txt | tr -d '\r\n')
          echo "HTTP $code"
          echo "Location: ${loc:-<none>}"
          if [ "$code" = "200" ]; then exit 0; fi
          if [[ "$code" =~ ^30(2|3|7|8)$ ]] && ([[ "$loc" == *"accounts.google.com"* ]] || [[ "$loc" == *"ServiceLogin"* ]] || [[ "$loc" == *"signin"* ]]); then
            echo "Domain-protected web app: login redirect detected (TEST) ✅"; exit 0
          fi
          echo "::error::TEST health check failed (code=${code} location=${loc})"; exit 1

  deploy-prod:
    runs-on: ubuntu-latest
    needs: [test-stage]
    timeout-minutes: 20

    steps:
      - name: "Checkout"
        uses: actions/checkout@v4

      - name: "Setup Node 18"
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: "Install latest clasp"
        run: npm i -g @google/clasp

      - name: "Write ~/.clasprc.json"
        env:
          CLASPRC_JSON: ${{ secrets.CLASPRC_JSON }}
        run: |
          set -euo pipefail
          [ -n "${CLASPRC_JSON:-}" ] || { echo "::error::Missing CLASPRC_JSON"; exit 1; }
          node -e "
            const fs=require('fs');const p=process.env.HOME+'/.clasprc.json';
            let s=process.env.CLASPRC_JSON||'';let j;
            try{ j=JSON.parse(s); }catch(e){ s=s.replace(/\s+/g,''); j=JSON.parse(Buffer.from(s,'base64').toString()); }
            if(!j.token && j.tokens && j.tokens.default){ j.token=j.tokens.default; }
            fs.writeFileSync(p, JSON.stringify(j,null,2));
          "
          test -s "$HOME/.clasprc.json"
          cp "$HOME/.clasprc.json" "$GITHUB_WORKSPACE/.clasprc.json"

      - name: "Push to Apps Script (PROD)"
        run: clasp push -f

      - name: "Deploy to PROD"
        env:
          GAS_DEPLOYMENT_ID: ${{ secrets.GAS_DEPLOYMENT_ID }}
        run: |
          [ -n "${GAS_DEPLOYMENT_ID:-}" ] || { echo "::error::Missing GAS_DEPLOYMENT_ID"; exit 1; }
          clasp deploy --deploymentId "$GAS_DEPLOYMENT_ID" -d "CI PROD ${GITHUB_SHA}"

      - name: "Health check (PROD)"
        env:
          GAS_DEPLOYMENT_ID: ${{ secrets.GAS_DEPLOYMENT_ID }}
        run: |
          set -e
          URL="https://script.google.com/macros/s/${GAS_DEPLOYMENT_ID}/exec?route=health&v=${GITHUB_SHA::7}"
          code=$(curl -sS -o /dev/null -w "%{http_code}" -D headers.txt "$URL" || true)
          loc=$(awk 'BEGIN{IGNORECASE=1}/^Location:/{print $2}' headers.txt | tr -d '\r\n')
          echo "HTTP $code"
          echo "Location: ${loc:-<none>}"
          if [ "$code" = "200" ]; then exit 0; fi
          if [[ "$code" =~ ^30(2|3|7|8)$ ]] && ([[ "$loc" == *"accounts.google.com"* ]] || [[ "$loc" == *"ServiceLogin"* ]] || [[ "$loc" == *"signin"* ]]); then
            echo "Domain-protected web app: login redirect detected (PROD) ✅"; exit 0
          fi
          echo "::error::PROD health check failed (code=${code} location=${loc})"; exit 1

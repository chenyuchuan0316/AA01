name: GAS staged test & deploy (single workflow)

permissions:
  contents: write
  pull-requests: write

on:
  pull_request:
    branches: [ "main" ]
  push:
    branches: [ "main" ]
  workflow_dispatch:

concurrency:
  group: gas-ci-${{ github.ref }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash

jobs:
  unit-tests:
    if: github.event_name == 'pull_request' || github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: "Checkout"
        uses: actions/checkout@v4

      - name: "Setup Node 20"
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: "Install dependencies"
        run: npm ci
        env:
          HUSKY: '0'

      - name: "Cache Playwright browsers"
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ hashFiles('package-lock.json') }}

      - name: "Install Playwright browsers"
        run: npx playwright install --with-deps

      - name: "Run unit tests (Jest)"
        run: npm test --if-present

  test-stage:
    if: github.ref == 'refs/heads/main' || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository)
    runs-on: ubuntu-latest
    needs: [unit-tests]
    timeout-minutes: 25
    env:
      PLAYWRIGHT_AUTH_STATE_B64: ${{ secrets.PLAYWRIGHT_AUTH_STATE }}
      GAS_WEBAPP_URL: ${{ secrets.GAS_WEBAPP_URL }}
      HAS_AUTH: ${{ secrets.PLAYWRIGHT_AUTH_STATE != '' }}
      HAS_WEBAPP_URL: ${{ secrets.GAS_WEBAPP_URL != '' }}
      HAS_REMOTE_TEST: ${{ secrets.PLAYWRIGHT_AUTH_STATE != '' && secrets.GAS_WEBAPP_URL != '' }}
      E2E_PATH: ${{ vars.E2E_PATH || '?route=AA01' }}
      E2E_TIMEOUT: ${{ vars.E2E_TIMEOUT || '30000' }}
      LOCAL_BASE_URL: ${{ vars.LOCAL_BASE_URL || 'http://127.0.0.1:3000/' }}

    steps:
      - name: "Checkout"
        uses: actions/checkout@v4

      - name: "Setup Node 20"
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: "Install dependencies"
        run: npm ci
        env:
          HUSKY: '0'

      - name: "Cache Playwright browsers"
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ hashFiles('package-lock.json') }}

      - name: "Install Playwright browsers"
        run: npx playwright install --with-deps

      - name: Restore Playwright auth state
        if: ${{ env.HAS_AUTH == 'true' }}
        run: |
          echo "${PLAYWRIGHT_AUTH_STATE_B64}" | base64 -d > auth.json
          echo "auth.json restored"

      - name: Run local UI E2E
        run: npm run e2e:ui

      - name: Preflight – forbid overriding GAS exec path
        run: |
          set -euo pipefail
          BASE="${BASE_URL:-}"
          PATH_INPUT="${PATH_INPUT:-}"
          if printf '%s' "$BASE" | grep -qE '^https://script\.google\.com/.*/exec/?$' && \
             printf '%s' "$PATH_INPUT" | grep -qE '^/exec(/|\?|$)'; then
            echo "::error::E2E_PATH should be query-only when base ends with /exec (use \"?route=...\")"
            exit 1
          fi
        env:
          BASE_URL: ${{ env.GAS_WEBAPP_URL }}
          PATH_INPUT: ${{ env.E2E_PATH }}

      - name: Auto-repair remote E2E (requires auth)
        if: ${{ env.HAS_REMOTE_TEST == 'true' }}
        run: node scripts/auto-repair.mjs --run "npm run e2e:remote" --verify "npm run health"
        env:
          GAS_WEBAPP_URL: ${{ env.GAS_WEBAPP_URL }}
          E2E_PATH: ${{ env.E2E_PATH }}
          E2E_TIMEOUT: ${{ env.E2E_TIMEOUT }}
          LOCAL_BASE_URL: ${{ env.LOCAL_BASE_URL }}
      - name: Debug secrets → env mapping
        run: |
          node -e "process.stdout.write('GAS_WEBAPP_URL length=' + String((process.env.GAS_WEBAPP_URL || '').length))"

      - name: Health check (200/302 or skip)
        if: ${{ env.HAS_WEBAPP_URL == 'true' }}
        run: npm run health
        env:
          GAS_WEBAPP_URL: ${{ env.GAS_WEBAPP_URL }}
          E2E_PATH: ${{ env.E2E_PATH }}
          E2E_TIMEOUT: ${{ env.E2E_TIMEOUT }}

      - name: Build artifact index
        if: always()
        run: node scripts/build-artifact-index.mjs
        env:
          ARTIFACT_SOURCES: |
            playwright-report
            artifacts
          ARTIFACT_INDEX_PATH: artifacts/index.json

      - name: Build artifact index
        if: always()
        run: node scripts/build-artifact-index.mjs
        env:
          ARTIFACT_SOURCES: |
            playwright-report
            artifacts
          ARTIFACT_INDEX_PATH: artifacts/index.json

      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: playwright-report
          path: |
            playwright-report
            artifacts/index.json
          if-no-files-found: ignore

      - name: "Install latest clasp"
        run: npm i -g @google/clasp

      # --- write clasprc (raw JSON 或 base64 皆可) ---
      - name: "Write ~/.clasprc.json"
        env:
          CLASPRC_JSON: ${{ secrets.CLASPRC_JSON }}
        run: |
          bash -eo pipefail <<'BASH'
          set -euo pipefail
          : "${CLASPRC_JSON:?Missing CLASPRC_JSON}"
          node -e "
            const fs=require('fs'), path=require('path');
            const p=process.env.HOME+'/.clasprc.json';
            let s=process.env.CLASPRC_JSON||''; let j;
            try { j=JSON.parse(s); }
            catch (e) { s=s.replace(/\s+/g,''); j=JSON.parse(Buffer.from(s,'base64').toString()); }
            if(!j.token && j.tokens?.default) j.token=j.tokens.default;
            fs.mkdirSync(path.dirname(p), {recursive:true});
            fs.writeFileSync(p, JSON.stringify(j,null,2));
          "
          test -s "$HOME/.clasprc.json"
          cp "$HOME/.clasprc.json" "$GITHUB_WORKSPACE/.clasprc.json"
          BASH

      - name: "Preflight: check TEST secrets & clasp & script"
        run: |
          set -e

          echo "=== 1) Secrets 注入 ==="
          echo "TEST_DEPLOYMENT_ID len: ${#TEST_DEPLOYMENT_ID}"
          if [ -z "${TEST_DEPLOYMENT_ID:-}" ]; then
            echo "::error::TEST_DEPLOYMENT_ID is empty. Fix: Repo → Settings → Secrets → Actions → add TEST_DEPLOYMENT_ID=<你的測試 AK…>"; exit 1;
          fi

          echo "=== 2) clasp 憑證 ==="
          echo "(clasp login status)"
          if clasp help whoami >/dev/null 2>&1; then
            if ! clasp whoami; then
              echo "::error::clasp not logged in or token invalid. Fix: 重取本機 ~/.clasprc.json（用 @fuancare.com.tw 有編輯權限的帳號），base64 上傳到 CLASPRC_JSON"; exit 1;
            fi
          else
            echo "::error::Installed clasp does not support whoami; upgrade to latest and provide CLASPRC_JSON token."; exit 1;
          fi

          echo "=== 3) 專案定位 ==="
          echo -n "scriptId in repo: "
          node -e "const fs=require('fs'); const j=JSON.parse(fs.readFileSync('.clasp.json','utf8')); if(!j.scriptId){console.error('Missing scriptId in .clasp.json'); process.exit(1);} console.log(j.scriptId);"
          echo "(deployments of this script)"
          if ! clasp deployments > before.txt; then
            echo "::error::Cannot list deployments. Usually bad credential or wrong scriptId"; exit 1;
          fi
          cat before.txt || true

          echo "=== 4) 解析部署清單（ID→版本） ==="
          node -e "const fs=require('fs');const t=fs.readFileSync('before.txt','utf8');const map={};for(const L of t.split(/\r?\n/)){const m=L.match(/(AK[\w-]{20,}).*@([0-9]+)/);if(m){map[m[1]]=m[2];}}console.log('Known IDs:',Object.keys(map).join(',')||'(none)'); if(!map[process.env.TEST_DEPLOYMENT_ID]){console.error('TEST_DEPLOYMENT_ID not found in this script.'); process.exit(2);} else {console.log('Found TEST_DEPLOYMENT_ID. current version =', map[process.env.TEST_DEPLOYMENT_ID]);}"
        env:
          TEST_DEPLOYMENT_ID: ${{ secrets.TEST_DEPLOYMENT_ID }}

      - name: "Guard: appsscript.json must declare webapp"
        run: |
          node - <<'EOF'
          const fs = require('fs');
          const path = require('path');

          const cwd = process.cwd();
          const candidates = [];

          try {
            const clasp = JSON.parse(fs.readFileSync(path.join(cwd, '.clasp.json'), 'utf8'));
            if (clasp.rootDir) {
              candidates.push(path.join(cwd, clasp.rootDir, 'appsscript.json'));
            }
          } catch (err) {
            if (err.code !== 'ENOENT') {
              console.warn('⚠️ 無法解析 .clasp.json：', err.message);
            }
          }

          candidates.push(path.join(cwd, 'appsscript.json'));

          let manifestPath = null;
          for (const candidate of candidates) {
            if (!candidate) continue;
            if (fs.existsSync(candidate) && fs.statSync(candidate).isFile()) {
              manifestPath = candidate;
              break;
            }
          }

          if (!manifestPath) {
            console.error('找不到 appsscript.json（根目錄或 .clasp.json 的 rootDir 中都沒有）');
            process.exit(1);
          }

          let manifest;
          try {
            manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
          } catch (err) {
            console.error('appsscript.json 不是有效 JSON：', err.message);
            process.exit(1);
          }

          if (!manifest.webapp || !manifest.webapp.access || !manifest.webapp.executeAs) {
            console.error('appsscript.json missing webapp.access/executeAs');
            process.exit(1);
          }
          const okLog = ['STACKDRIVER','CLOUD','NONE'].includes(manifest.exceptionLogging || 'STACKDRIVER');
          if (!okLog) {
            console.error('exceptionLogging must be STACKDRIVER|CLOUD|NONE, got:', manifest.exceptionLogging);
            process.exit(1);
          }
          const rel = path.relative(cwd, manifestPath) || 'appsscript.json';
          console.log('webapp OK:', manifest.webapp, 'manifest=', rel, 'exceptionLogging=', manifest.exceptionLogging);
          EOF

      # BEFORE snapshot（文字解析 fallback）
      - name: "Snapshot BEFORE"
        run: |
          set -e
          clasp deployments > before.txt || true
          clasp deployments --json > before.json || true
          node -e "
            const fs=require('fs');
            const map={};
            const safeRead=(file)=>{ try { return fs.readFileSync(file,'utf8'); } catch (err) { return ''; } };

            const jsonText=safeRead('before.json').trim();
            if(jsonText){
              try {
                const parsed=JSON.parse(jsonText);
                const list=Array.isArray(parsed)?parsed:(parsed && Array.isArray(parsed.deployments)?parsed.deployments:[]);
                for(const dep of list){
                  const depId=dep && dep.deploymentId;
                  const depVer=dep && dep.deploymentConfig && (dep.deploymentConfig.versionNumber ?? dep.deploymentConfig.version);
                  if(depId){
                    map[depId]=depVer!=null?String(depVer):'';
                  }
                }
              } catch (err) {
                console.warn('⚠️ 無法解析 before.json：', err.message);
              }
            }

            if(!Object.keys(map).length){
              const text=safeRead('before.txt');
              const regex=/(AK[\w-]{20,})/g;
              let m;
              while((m=regex.exec(text))){
                if(!map[m[1]]){
                  map[m[1]]='';
                }
              }
            }

            const keys=Object.keys(map);
            fs.writeFileSync('before.map.json', JSON.stringify(map, null, 2));
            console.log('Known deployment keys:', keys.length?keys.join(', '):'(none)');
          "

      - name: "Check TEST_DEPLOYMENT_ID availability"
        id: check-test-deployment
        env:
          TEST_DEPLOYMENT_ID: ${{ secrets.TEST_DEPLOYMENT_ID }}
        run: |
          if [ -z "${TEST_DEPLOYMENT_ID:-}" ]; then
            echo "::warning::TEST_DEPLOYMENT_ID secret is not available for this workflow run."
            echo "has_secret=false" >> "$GITHUB_OUTPUT"
          else
            echo "has_secret=true" >> "$GITHUB_OUTPUT"
          fi

      - name: "Ensure TEST_DEPLOYMENT_ID exists BEFORE"
        if: steps.check-test-deployment.outputs.has_secret == 'true'
        env:
          TEST_DEPLOYMENT_ID: ${{ secrets.TEST_DEPLOYMENT_ID }}
        run: |
          node -e "
            const fs=require('fs');
            const hasOwn=Object.prototype.hasOwnProperty;
            const id=(process.env.TEST_DEPLOYMENT_ID||'').trim();
            if(!id){
              console.error('Missing TEST_DEPLOYMENT_ID secret.');
              process.exit(1);
            }
            const map=JSON.parse(fs.readFileSync('before.map.json','utf8'));
            if(!hasOwn.call(map, id)){
              const known=Object.keys(map);
              console.error('TEST_DEPLOYMENT_ID not found. Known deployments: '+(known.length?known.join(', '):'(none)'));
              process.exit(1);
            }
            const current=map[id];
            console.log('Found test deployment BEFORE. Current version =', current?current:'<unknown>');
          "

      # --- push & deploy to TEST ---
      - name: "Inject CI env (TEST)"
        env:
          SHA: ${{ github.sha }}
        run: |
          set -e
          SHORT_SHA="${SHA::7}"
          cat > 00_ci_env.gs <<EOF
          const CI_ENV = 'TEST';
          const CI_SHA_SHORT = '${SHORT_SHA}';
          EOF

      - name: "Push to Apps Script (TEST)"
        run: clasp push -f

      - name: "Create new version (TEST)"
        id: mkver-test
        run: |
          set -e
          out=$(clasp version "[TEST] CI ${GITHUB_SHA::7}" || true)
          echo "$out"
          ver=$(echo "$out" | sed -n "s/Created version \([0-9][0-9]*\).*/\1/p")
          if [ -z "$ver" ]; then echo "::error::Failed to parse version"; exit 1; fi
          echo "NEW_VER=$ver" >> "$GITHUB_ENV"
          echo "new_ver=$ver" >> "$GITHUB_OUTPUT"

      - name: "Update deployment to NEW_VER (TEST)"
        if: steps.check-test-deployment.outputs.has_secret == 'true'
        env:
          TEST_DEPLOYMENT_ID: ${{ secrets.TEST_DEPLOYMENT_ID }}
        run: |
          set -e
          [ -n "${TEST_DEPLOYMENT_ID:-}" ] || { echo "::error::Missing TEST_DEPLOYMENT_ID"; exit 1; }
          [ -n "${NEW_VER:-}" ] || { echo "::error::Missing NEW_VER"; exit 1; }
          clasp deploy --deploymentId "$TEST_DEPLOYMENT_ID" --versionNumber "$NEW_VER" -d "[TEST] CI ${GITHUB_SHA::7}"
      # AFTER snapshot (TEST)
      - name: "Verify deployment points to NEW_VER (TEST)"
        if: steps.check-test-deployment.outputs.has_secret == 'true'
        env:
          TEST_DEPLOYMENT_ID: ${{ secrets.TEST_DEPLOYMENT_ID }}
        run: |
          set -e
          clasp deployments > after.txt || true
          clasp deployments --json > after.json || true
          node -e "
            const fs=require('fs');
            const id=(process.env.TEST_DEPLOYMENT_ID||'').trim();
            const ver=(process.env.NEW_VER||'').trim();
            if(!id){ console.error('Missing TEST_DEPLOYMENT_ID secret.'); process.exit(1); }
            if(!ver){ console.error('Missing NEW_VER env.'); process.exit(1); }

            const map={};
            const safeRead=(file)=>{ try { return fs.readFileSync(file,'utf8'); } catch (err) { return ''; } };

            const jsonText=safeRead('after.json').trim();
            if(jsonText){
              try {
                const parsed=JSON.parse(jsonText);
                const list=Array.isArray(parsed)?parsed:(parsed&&Array.isArray(parsed.deployments)?parsed.deployments:[]);
                for(const dep of list){
                  const depId=dep && dep.deploymentId;
                  const depVer=dep && dep.deploymentConfig && (dep.deploymentConfig.versionNumber ?? dep.deploymentConfig.version);
                  if(depId && (depVer || depVer===0)){
                    map[depId]=String(depVer);
                  }
                }
              } catch (err) {
                console.warn('⚠️ 無法解析 after.json：', err.message);
              }
            }

            if(!Object.keys(map).length){
              const text=safeRead('after.txt');
              const lines=text.split(/\r?\n/);
              for(const L of lines){
                const m=L.match(/(AK[\w-]{20,}).*@([0-9]+)/);
                if(m){
                  map[m[1]]=m[2];
                }
              }
            }

            const current=map[id];
            if(!current){
              console.error('TEST_DEPLOYMENT_ID not found AFTER. Known deployments: '+(Object.keys(map).length?Object.keys(map).join(', '):'(none)'));
              process.exit(1);
            }
            if(current!==ver){
              console.error('Deployment still points to', current, 'expected', ver);
              process.exit(1);
            }
            console.log('Deployment updated to version', current);
          "

      - name: "Debug TEST_DEPLOYMENT_ID length"
        env:
          TEST_DEPLOYMENT_ID: ${{ secrets.TEST_DEPLOYMENT_ID }}
        run: |
          if [ -n "${TEST_DEPLOYMENT_ID:-}" ]; then
            echo "len=${#TEST_DEPLOYMENT_ID}"
          else
            echo "len=0 (empty)"
          fi

      - name: "Run E2E tests (Puppeteer) against TEST"
        if: steps.check-test-deployment.outputs.has_secret == 'true'
        env:
          TEST_DEPLOYMENT_ID: ${{ secrets.TEST_DEPLOYMENT_ID }}
        run: npm run e2e --if-present

      - name: "Upload responsive screenshots"
        if: steps.check-test-deployment.outputs.has_secret == 'true' && always()
        env:
          TEST_DEPLOYMENT_ID: ${{ secrets.TEST_DEPLOYMENT_ID }}
        uses: actions/upload-artifact@v4
        with:
          name: responsive-screenshots
          path: artifacts/screenshots/**/*.png
          if-no-files-found: warn

      # --- Health check on TEST（容忍 302 登入轉向） ---
      - name: "Health check (TEST)"
        if: steps.check-test-deployment.outputs.has_secret == 'true'
        env:
          TEST_DEPLOYMENT_ID: ${{ secrets.TEST_DEPLOYMENT_ID }}
        run: |
          set -e
          URL="https://script.google.com/macros/s/${TEST_DEPLOYMENT_ID}/exec?route=health&v=${GITHUB_SHA::7}"
          code=$(curl -sS -o /dev/null -w "%{http_code}" -D headers.txt "$URL" || true)
          loc=$(awk 'BEGIN{IGNORECASE=1}/^Location:/{print $2}' headers.txt | tr -d '\r\n')
          echo "HTTP $code"
          echo "Location: ${loc:-<none>}"
          if [ "$code" = "200" ]; then exit 0; fi
          if [[ "$code" =~ ^30(2|3|7|8)$ ]] && ([[ "$loc" == *"accounts.google.com"* ]] || [[ "$loc" == *"ServiceLogin"* ]] || [[ "$loc" == *"signin"* ]]); then
            echo "Domain-protected web app: login redirect detected (TEST) ✅"; exit 0
          fi
          echo "::error::TEST health check failed (code=${code} location=${loc})"; exit 1

  deploy-prod:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    needs: [test-stage]
    timeout-minutes: 20

    steps:
      - name: "Checkout"
        uses: actions/checkout@v4

      - name: "Setup Node 18"
        uses: actions/setup-node@v4
        with:
          node-version: 18


      - name: "Install latest clasp"
        run: npm i -g @google/clasp

      - name: "Write ~/.clasprc.json"
        env:
          CLASPRC_JSON: ${{ secrets.CLASPRC_JSON }}
        run: |
          bash -eo pipefail <<'BASH'
          set -euo pipefail
          : "${CLASPRC_JSON:?Missing CLASPRC_JSON}"
          node -e "
            const fs=require('fs'), path=require('path');
            const p=process.env.HOME+'/.clasprc.json';
            let s=process.env.CLASPRC_JSON||''; let j;
            try { j=JSON.parse(s); }
            catch (e) { s=s.replace(/\s+/g,''); j=JSON.parse(Buffer.from(s,'base64').toString()); }
            if(!j.token && j.tokens?.default) j.token=j.tokens.default;
            fs.mkdirSync(path.dirname(p), {recursive:true});
            fs.writeFileSync(p, JSON.stringify(j,null,2));
          "
          test -s "$HOME/.clasprc.json"
          cp "$HOME/.clasprc.json" "$GITHUB_WORKSPACE/.clasprc.json"
          BASH

      - name: "Snapshot BEFORE"
        run: |
          set -e
          clasp deployments > before.txt || true
          clasp deployments --json > before.json || true
          node -e "
            const fs=require('fs');
            const map={};
            const safeRead=(file)=>{ try { return fs.readFileSync(file,'utf8'); } catch (err) { return ''; } };

            const jsonText=safeRead('before.json').trim();
            if(jsonText){
              try {
                const parsed=JSON.parse(jsonText);
                const list=Array.isArray(parsed)?parsed:(parsed && Array.isArray(parsed.deployments)?parsed.deployments:[]);
                for(const dep of list){
                  const depId=dep && dep.deploymentId;
                  const depVer=dep && dep.deploymentConfig && (dep.deploymentConfig.versionNumber ?? dep.deploymentConfig.version);
                  if(depId){
                    map[depId]=depVer!=null?String(depVer):'';
                  }
                }
              } catch (err) {
                console.warn('⚠️ 無法解析 before.json：', err.message);
              }
            }

            if(!Object.keys(map).length){
              const text=safeRead('before.txt');
              const regex=/(AK[\w-]{20,})/g;
              let m;
              while((m=regex.exec(text))){
                if(!map[m[1]]){
                  map[m[1]]='';
                }
              }
            }

            const keys=Object.keys(map);
            fs.writeFileSync('before.map.json', JSON.stringify(map, null, 2));
            console.log('Known deployment keys:', keys.length?keys.join(', '):'(none)');
          "

      - name: "Ensure GAS_DEPLOYMENT_ID exists BEFORE"
        env:
          GAS_DEPLOYMENT_ID: ${{ secrets.GAS_DEPLOYMENT_ID }}
        run: |
          node -e "
            const fs=require('fs');
            const hasOwn=Object.prototype.hasOwnProperty;
            const id=(process.env.GAS_DEPLOYMENT_ID||'').trim();
            if(!id){
              console.error('Missing GAS_DEPLOYMENT_ID secret.');
              process.exit(1);
            }
            const map=JSON.parse(fs.readFileSync('before.map.json','utf8'));
            if(!hasOwn.call(map, id)){
              const known=Object.keys(map);
              console.error('GAS_DEPLOYMENT_ID not found. Known deployments: '+(known.length?known.join(', '):'(none)'));
              process.exit(1);
            }
            const current=map[id];
            console.log('Found prod deployment BEFORE. Current version =', current?current:'<unknown>');
          "

      - name: "Inject CI env (PROD)"
        env:
          SHA: ${{ github.sha }}
        run: |
          set -e
          SHORT_SHA="${SHA::7}"
          cat > 00_ci_env.gs <<EOF
          const CI_ENV = 'PROD';
          const CI_SHA_SHORT = '${SHORT_SHA}';
          EOF

      - name: "Push to Apps Script (PROD)"
        run: clasp push -f

      - name: "Create new version (PROD)"
        id: mkver-prod
        run: |
          set -e
          out=$(clasp version "[PROD] CI ${GITHUB_SHA::7}" || true)
          echo "$out"
          ver=$(echo "$out" | sed -n "s/Created version \([0-9][0-9]*\).*/\1/p")
          if [ -z "$ver" ]; then echo "::error::Failed to parse version"; exit 1; fi
          echo "NEW_VER=$ver" >> "$GITHUB_ENV"
          echo "new_ver=$ver" >> "$GITHUB_OUTPUT"

      - name: "Update deployment to NEW_VER (PROD)"
        env:
          GAS_DEPLOYMENT_ID: ${{ secrets.GAS_DEPLOYMENT_ID }}
        run: |
          set -e
          [ -n "${GAS_DEPLOYMENT_ID:-}" ] || { echo "::error::Missing GAS_DEPLOYMENT_ID"; exit 1; }
          [ -n "${NEW_VER:-}" ] || { echo "::error::Missing NEW_VER"; exit 1; }
          clasp deploy --deploymentId "$GAS_DEPLOYMENT_ID" --versionNumber "$NEW_VER" -d "[PROD] CI ${GITHUB_SHA::7}"

      - name: "Verify deployment points to NEW_VER (PROD)"
        env:
          GAS_DEPLOYMENT_ID: ${{ secrets.GAS_DEPLOYMENT_ID }}
        run: |
          set -e

          clasp deployments > after.txt || true
          clasp deployments --json > after.json || true
          node -e "
            const fs=require('fs');
            const id=(process.env.GAS_DEPLOYMENT_ID||'').trim();
            const ver=(process.env.NEW_VER||'').trim();
            if(!id){ console.error('Missing GAS_DEPLOYMENT_ID secret.'); process.exit(1); }
            if(!ver){ console.error('Missing NEW_VER env.'); process.exit(1); }

            const map={};
            const safeRead=(file)=>{ try { return fs.readFileSync(file,'utf8'); } catch (err) { return ''; } };

            const jsonText=safeRead('after.json').trim();
            if(jsonText){
              try {
                const parsed=JSON.parse(jsonText);
                const list=Array.isArray(parsed)?parsed:(parsed&&Array.isArray(parsed.deployments)?parsed.deployments:[]);
                for(const dep of list){
                  const depId=dep && dep.deploymentId;
                  const depVer=dep && dep.deploymentConfig && (dep.deploymentConfig.versionNumber ?? dep.deploymentConfig.version);
                  if(depId && (depVer || depVer===0)){
                    map[depId]=String(depVer);
                  }
                }
              } catch (err) {
                console.warn('⚠️ 無法解析 after.json：', err.message);
              }
            }

            if(!Object.keys(map).length){
              const text=safeRead('after.txt');
              const lines=text.split(/\r?\n/);
              for(const L of lines){
                const m=L.match(/(AK[\w-]{20,}).*@([0-9]+)/);
                if(m){
                  map[m[1]]=m[2];
                }
              }
            }

            const current=map[id];
            if(!current){
              console.error('GAS_DEPLOYMENT_ID not found AFTER. Known deployments: '+(Object.keys(map).length?Object.keys(map).join(', '):'(none)'));
              process.exit(1);
            }
            if(current!==ver){
              console.error('Deployment still points to', current, 'expected', ver);
              process.exit(1);
            }
            console.log('Deployment updated to version', current);
          "

      - name: "Health check (PROD)"
        env:
          GAS_DEPLOYMENT_ID: ${{ secrets.GAS_DEPLOYMENT_ID }}
        run: |
          set -e
          URL="https://script.google.com/macros/s/${GAS_DEPLOYMENT_ID}/exec?route=health&v=${GITHUB_SHA::7}"
          code=$(curl -sS -o /dev/null -w "%{http_code}" -D headers.txt "$URL" || true)
          loc=$(awk 'BEGIN{IGNORECASE=1}/^Location:/{print $2}' headers.txt | tr -d '\r\n')
          echo "HTTP $code"
          echo "Location: ${loc:-<none>}"
          if [ "$code" = "200" ]; then exit 0; fi
          if [[ "$code" =~ ^30(2|3|7|8)$ ]] && ([[ "$loc" == *"accounts.google.com"* ]] || [[ "$loc" == *"ServiceLogin"* ]] || [[ "$loc" == *"signin"* ]]); then
            echo "Domain-protected web app: login redirect detected (PROD) ✅"; exit 0
          fi
          echo "::error::PROD health check failed (code=${code} location=${loc})"; exit 1

name: Deploy GAS Web App

on:
  push:
    branches: ["main"]
  workflow_dispatch: {}

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install clasp
        run: npm i -g @google/clasp

      # 從 Base64 Secret 還原登入憑證
      - name: Restore ~/.clasprc.json from Base64
        run: |
          echo "${{ secrets.CLASPRC_JSON_B64 }}" | base64 -d > ~/.clasprc.json
          chmod 600 ~/.clasprc.json
          node -e "JSON.parse(require('fs').readFileSync(process.env.HOME+'/.clasprc.json','utf8')); console.log('✔ ~/.clasprc.json OK')"

      # 防呆：部署 ID 必須出現在 URL 內（避免填到 Library 的 ID）
      - name: Preflight: ID must match URL
        env:
          ID: ${{ vars.GAS_DEPLOY_ID }}
          URL: ${{ vars.GAS_WEBAPP_URL }}
        run: |
          echo "ID=$ID"
          echo "URL=$URL"
          case "$URL" in *"$ID"*) echo "✔ ID found in URL";; *)
            echo "::error title=Wrong variables::GAS_DEPLOY_ID is not contained in GAS_WEBAPP_URL. Are you using a Library ID?"; exit 1;;
          esac

      # 產生乾淨 .clasp.json（無 BOM）
      - name: Create clean .clasp.json (no BOM)
        env:
          GAS_SCRIPT_ID: ${{ vars.GAS_SCRIPT_ID }}
        run: |
          node <<'NODE'
          const fs=require('fs'); const id=(process.env.GAS_SCRIPT_ID||'').trim();
          if(!id){ console.error('❌ GAS_SCRIPT_ID not set'); process.exit(1); }
          fs.writeFileSync('.clasp.json', JSON.stringify({scriptId:id}));
          console.log('✔ .clasp.json written');
          NODE

      # 忽略雜檔，避免把 node_modules 推上去
      - name: Ensure .claspignore
        run: |
          cat > .claspignore <<'EOF'
          node_modules/**
          .github/**
          .git/**
          dist/**
          build/**
          coverage/**
          .vscode/**
          *.map
          README*
          LICENSE*
          *.md
          scripts/**
          test/**
          package.json
          package-lock.json
          pnpm-lock.yaml
          yarn.lock
          EOF

      # 上傳程式
      - name: Push code to GAS
        run: clasp push --force

      # 用同一個部署 ID 更新（網址不變）
      - name: Create version & update deployment
        env:
          GAS_DEPLOY_ID: ${{ vars.GAS_DEPLOY_ID }}
        run: |
          DESC="ci build $GITHUB_SHA"
          OUT="$(clasp version "$DESC")"
          echo "$OUT"
          VER="$(echo "$OUT" | sed -n 's/.*version \([0-9]\+\).*/\1/p')"
          if [ -z "$VER" ]; then echo "Cannot parse version"; exit 1; fi
          clasp deploy -i "$GAS_DEPLOY_ID" -V "$VER" -d "$DESC"

      # 先匿名探測；若失敗（多半是網域限制）再走 OAuth
      - name: Probe Web App anonymously
        id: probe
        env:
          URL: ${{ vars.GAS_WEBAPP_URL }}
        run: |
          set +e
          code=$(curl -s -o resp.txt -w "%{http_code}" -L "$URL")
          echo "http_code=$code"
          if [ "$code" -ge 200 ] && [ "$code" -lt 400 ]; then
            echo "PROBE_OK=true" >> $GITHUB_ENV
            head -c 1024 resp.txt || true
            exit 0
          else
            echo "PROBE_OK=false" >> $GITHUB_ENV
            exit 0
          fi

      - name: Test Web App with OAuth
        if: env.PROBE_OK == 'false'
        env:
          URL: ${{ vars.GAS_WEBAPP_URL }}
          GAS_OAUTH_CLIENT_ID: ${{ secrets.GAS_OAUTH_CLIENT_ID }}
          GAS_OAUTH_CLIENT_SECRET: ${{ secrets.GAS_OAUTH_CLIENT_SECRET }}
        run: |
          node <<'NODE'
          const fs = require('fs'), https = require('https');
          const cfg = JSON.parse(fs.readFileSync(process.env.HOME+'/.clasprc.json','utf8'));
          const refresh = cfg.token?.refresh_token || cfg.token?.refreshToken || '';
          if(!refresh){ console.error('❌ No refresh_token in ~/.clasprc.json'); process.exit(1); }
          const o = cfg.oauth2ClientSettings || cfg.oauth2 || {};
          const clientId =
            process.env.GAS_OAUTH_CLIENT_ID ||
            o.clientId || o.web?.client_id || o.installed?.client_id ||
            '1072944905499-vm2v2i5dvn0a0d2o4ca36i1vge8cvbn0.apps.googleusercontent.com';
          const clientSecret =
            process.env.GAS_OAUTH_CLIENT_SECRET ||
            o.clientSecret || o.web?.client_secret || o.installed?.client_secret ||
            'v6V3fKV_zWU7iw1DrpO1rknX';

          const body = new URLSearchParams({
            client_id: clientId, client_secret: clientSecret,
            refresh_token: refresh, grant_type: 'refresh_token'
          }).toString();

          const opt = {hostname:'oauth2.googleapis.com', path:'/token', method:'POST',
            headers:{'Content-Type':'application/x-www-form-urlencoded','Content-Length':Buffer.byteLength(body)}};
          const req = https.request(opt, res => { let buf=''; res.on('data',d=>buf+=d); res.on('end',()=>{
            try{ const tok = JSON.parse(buf).access_token; if(!tok) throw new Error(buf);
              fs.writeFileSync('ACCESS_TOKEN', tok); console.log('✔ access_token acquired'); }
            catch(e){ console.error('Token response:', buf); process.exit(1); }
          })});
          req.on('error', e=>{ console.error(e); process.exit(1); });
          req.write(body); req.end();
          NODE

          ACCESS_TOKEN=$(cat ACCESS_TOKEN)
          code=$(curl -s -o resp.txt -w "%{http_code}" -L -H "Authorization: Bearer $ACCESS_TOKEN" "$URL")
          echo "http_code=$code"
          head -c 1024 resp.txt || true
          test "$code" -ge 200 -a "$code" -lt 400

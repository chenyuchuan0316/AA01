name: Deploy GAS via OIDC ADC

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: read
  id-token: write   # 必須：讓 GitHub 簽發 OIDC Token 給 auth@v2

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # 1) OIDC → WIF → 取得 ADC（不需要 lifetime）
      - id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }}
          service_account: ${{ secrets.GCP_SA_EMAIL }}

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - run: npm ci

      # 2) 診斷：確認 ADC 憑證檔被匯出
      - name: Debug ADC env
        shell: bash
        run: |
          echo "GOOGLE_APPLICATION_CREDENTIALS=$GOOGLE_APPLICATION_CREDENTIALS"
          echo "CLOUDSDK_AUTH_CREDENTIAL_FILE_OVERRIDE=$CLOUDSDK_AUTH_CREDENTIAL_FILE_OVERRIDE"
          test -f "$GOOGLE_APPLICATION_CREDENTIALS" && echo "ADC file exists" || (echo "ADC file missing"; exit 1)

      # 3) 安裝 googleapis 用 ADC 呼叫 Script API
      - run: npm i googleapis@^126

      # 4) 建立部署腳本（ADC→updateContent→createVersion→createDeployment）
      - name: Write deploy script
        run: |
          cat > gas-deploy.mjs <<'EOS'
          import fs from 'fs';
          import path from 'path';
          import {GoogleAuth} from 'google-auth-library';
          import {google} from 'googleapis';

          // === 讀 .clasp.json，取得 scriptId 與 rootDir ===
          const clasp = JSON.parse(fs.readFileSync('.clasp.json','utf8'));
          const scriptId = (clasp.scriptId || process.env.SCRIPT_ID || '').trim();
          const rootDir = clasp.rootDir || '.';
          if (!scriptId) throw new Error('SCRIPT_ID/.clasp.json.scriptId 未設定');

          // === 收集檔案（忽略 .git、.github、node_modules 等）===
          const IGNORE_DIRS = new Set(['.git','.github','node_modules','.vscode']);
          const files = [];
          function walk(dir) {
            for (const name of fs.readdirSync(dir)) {
              const p = path.join(dir,name);
              const rel = path.relative(rootDir, p);
              // 跳過 rootDir 之外與忽略資料夾
              if (rel.startsWith('..')) continue;
              const st = fs.statSync(p);
              if (st.isDirectory()) {
                if (IGNORE_DIRS.has(name)) continue;
                walk(p);
              } else {
                // 只處理 .gs/.js/.html 與 manifest
                if (name === 'appsscript.json' && dir === rootDir) {
                  const manifest = fs.readFileSync(p,'utf8');
                  files.push({ name: 'appsscript', type: 'JSON', source: manifest });
                } else if (/\.(gs|js)$/i.test(name)) {
                  const src = fs.readFileSync(p,'utf8');
                  const fname = path.basename(name, path.extname(name));
                  files.push({ name: fname, type: 'SERVER_JS', source: src });
                } else if (/\.(html)$/i.test(name)) {
                  const src = fs.readFileSync(p,'utf8');
                  const fname = path.basename(name, path.extname(name));
                  files.push({ name: fname, type: 'HTML', source: src });
                }
              }
            }
          }
          walk(rootDir);

          if (!files.find(f => f.name==='appsscript' && f.type==='JSON'))
            throw new Error('找不到 appsscript.json（請放在 rootDir 並命名正確）');

          console.log('Collected', files.length, 'files');

          // === 用 ADC 取權限 ===
          const auth = new GoogleAuth({
            scopes: [
              'https://www.googleapis.com/auth/script.projects',
              'https://www.googleapis.com/auth/script.deployments'
            ]
          });
          const client = await auth.getClient();
          const script = google.script({version:'v1', auth: client});

          // === 1) updateContent ===
          await script.projects.updateContent({
            scriptId,
            requestBody: { files }
          });
          console.log('updateContent OK');

          // === 2) createVersion ===
          const desc = process.env.VERSION_DESC || `CI ${new Date().toISOString()}`;
          const ver = await script.projects.versions.create({
            scriptId,
            requestBody: { description: desc }
          });
          const versionNumber = ver.data?.versionNumber;
          console.log('createVersion OK:', versionNumber);

          // === 3) createDeployment ===
          await script.projects.deployments.create({
            scriptId,
            requestBody: {
              versionNumber,
              manifestFileName: 'appsscript',
              description: process.env.DEPLOY_DESC || desc
            }
          });
          console.log('createDeployment OK');
          EOS

      # 5) 寫入 .clasp.json（rootDir 指向 manifest 所在位置：此範例為根目錄）
      - name: Write .clasp.json
        run: |
          echo '{ "scriptId": "${{ secrets.SCRIPT_ID }}", "rootDir": "." }' > .clasp.json
          cat .clasp.json

      # 6) 以 ADC 執行部署腳本
      - name: Run deploy script (ADC)
        env:
          VERSION_DESC: "CI $(date -u +'%Y-%m-%dT%H:%M:%SZ')"
          DEPLOY_DESC:  "CI auto deploy $(date -u +'%Y-%m-%dT%H:%M:%SZ')"
        run: node gas-deploy.mjs
